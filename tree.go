package tree

import (
	"strings"

	"github.com/charmbracelet/bubbles/key"
	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

// NodeState is used for passing information from a Treesih element to the view itself
type NodeState uint16

type Model struct {
  KeyMap KeyMap
  Styles Styles
  Symbols Symbols

	focus  bool
	cursor int

	tree   Nodes

	viewport viewport.Model
}

type Node interface {
	tea.Model
	Parent() Node
	Children() Nodes
	State() NodeState
}

type Nodes []Node

func New(t Nodes) Model {
  return Model{
    KeyMap: DefaultKeyMap(),
    Styles: DefaultStyles(),
    Symbols: DefaultSymbols(),

    tree: t,

    viewport: viewport.New(0,1),
    focus: true,
  }
}

func (n Nodes) at(i int) Node {
  j := 0
  for _, p := range n {
    if isHidden(p) {
      continue
    }
    if j == i {
      return p
    }

    if isExpanded(p) && p.Children() != nil {
      if nn := p.Children().at(i - j - 1); nn != nil {
        return nn
      }
      j += len(p.Children().visibleNodes())
    }
    j++

  }
  return nil
}

func (s NodeState) Is(st NodeState) bool {
	return s&st == st
}

const (
	NodeNone NodeState = 0

	// NodeCollapsed hints that the current node is collapsed
	NodeCollapsed NodeState = 1 << iota
	NodeSelected
	// NodeCollapsible hints that the current node can be collapsed
	NodeCollapsible
	// NodeHidden hints that the current node is not going to be displayed
	NodeHidden
	// NodeLastChild shows the node to be the last in the children list
	NodeLastChild
)

var (
	width = lipgloss.Width

	defaultStyle         = lipgloss.NewStyle()
	defaultSelectedStyle = defaultStyle.Reverse(true)
)

func (n Nodes) visibleNodes() Nodes {
  visible := make(Nodes, 0)
  for _, nn := range n {
    if isHidden(nn) {
      continue
    }
    visible = append(visible, nn)
    if isCollapsible(nn) && isExpanded(nn) {
      visible = append(visible, nn.Children().visibleNodes()...)
    }
  }
  return visible
}

// KeyMap defines keybindings.
// It statisfies to the github.com/charm/bubbles/help.KeyMap interface.
type KeyMap struct {
  LineUp       key.Binding
	LineDown     key.Binding
	PageUp       key.Binding
	PageDown     key.Binding
	HalfPageUp   key.Binding
	HalfPageDown key.Binding
	GotoTop      key.Binding
	GotoBottom   key.Binding

	Expand key.Binding
}

func DefaultKeyMap() KeyMap {
	return KeyMap{
		LineUp: key.NewBinding(
			key.WithKeys("up", "k"),
			key.WithHelp("↑/k", "up"),
		),
		LineDown: key.NewBinding(
			key.WithKeys("down", "j"),
			key.WithHelp("↓/j", "down"),
		),
		PageUp: key.NewBinding(
			key.WithKeys("b", "pgup"),
			key.WithHelp("b/pgup", "page up"),
		),
		PageDown: key.NewBinding(
			key.WithKeys("f", "pgdown", " "),
			key.WithHelp("f/pgdn", "page down"),
		),
		HalfPageUp: key.NewBinding(
			key.WithKeys("u", "ctrl+u"),
			key.WithHelp("u", "½ page up"),
		),
		HalfPageDown: key.NewBinding(
			key.WithKeys("d", "ctrl+d"),
			key.WithHelp("d", "½ page down"),
		),
		GotoTop: key.NewBinding(
			key.WithKeys("home", "g"),
			key.WithHelp("g/home", "go to start"),
		),
		GotoBottom: key.NewBinding(
			key.WithKeys("end", "G"),
			key.WithHelp("G/end", "go to end"),
		),
		Expand: key.NewBinding(
			key.WithKeys("o"),
			key.WithHelp("o", "toggle expand for current node"),
		),
	}
}

// Styles contains style definitions for this list component. By default, these
// values are generated by DefaultStyles.
type Styles struct {
	Line     lipgloss.Style
	Selected lipgloss.Style
}

// DefaultStyles returns a set of default style definitions for this tree.
func DefaultStyles() Styles {
	return Styles{
		Line:     defaultStyle,
		Selected: defaultSelectedStyle,
	}
}

type Symbol string

func (s Symbol) draw(p int) string {
  if len(s) == 0 {
    return strings.Repeat(" ", p)
  }
  sl := width(string(s))
  if p < sl {
    return string(s)
  }

  return strings.Repeat(" ", p-sl) + string(s)
}

type Symbols struct {
  Width int

  Vertical Symbol
  VerticalAndRight Symbol
  UpAndRight Symbol
  Horizontal Symbol

  Collapsed string
  Expanded string
  Ellipsis string
}

func DefaultSymbols() Symbols {
  return Symbols {
    Width:            3,
		Vertical:         "│ ",
		VerticalAndRight: "├─",
		UpAndRight:       "└─",

		Ellipsis: "…",
  }
}

func (m *Model) currentNode() Node {
  if m.tree == nil || m.cursor < 0 {
    return nil
  }
  return m.tree.at(m.cursor)
}

type Msg string

func (m *Model) init() tea.Msg {
  return Msg("initialized")
}

func (m *Model) Init() tea.Cmd {
  return m.init
}

func (m *Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
  if !m.focus {
    return m, nil
  }

  var err error

  switch msg := msg.(type) {
  case Msg:
    return m, m.setCurrentNode(m.cursor)
  }

  if err != nil {
    return m, erred(err)
  }

  return m, nil
}

func (m *Model) View() string {
  return ""
}

// ToggleExpand toggles the expand state of the node pointed at by m.cursor
func (m *Model) ToggleExpand() {
  n := m.currentNode()
  if n == nil {
    return
  }

  if !isCollapsible(n) {
    return
  }
  n.Update(n.State() ^ NodeCollapsed)
}

func isHidden(n Node) bool {
  return n.State().Is(NodeHidden)
}

func isExpanded(n Node) bool {
  return !n.State().Is(NodeCollapsed)
}

func isCollapsible(n Node) bool {
  return n.State().Is(NodeCollapsible)
}

func max(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func min(a, b int) int {
	if a > b {
		return a
	}
	return b
}
